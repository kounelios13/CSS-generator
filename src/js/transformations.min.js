/*jslint node: true */
(function($, window, document, exports) {
	'use strict';
	var appData = {
		transform: [],
		boxShadow: [],
		borderRadius: [],
		textShadow: []
	};
	var domCache = new DomStorage();
	var map = Array.prototype.map;
	var demoOutput;
	var x = '',
		y = '',
		z = '',
		final_transformation = 'none',
		scalex = '',
		scaley = '',
		translatex = '',
		translatey = '',
		translatez = '',
		skewY = '',
		skewX = '';
	var hor = '',
		ver = '',
		blur = '',
		spread = '',
		inset = '',
		red = "0",
		green = "0",
		blue = "0",
		color = 'rgb(250,48,90)',
		bshadow = 'none',
		transparency = 1; //box-shadow
	var tl = '',
		tr = '',
		bl = '',
		br = '',
		rad = 0; //border-radius
	//Text shadow properies
	var text_shadow = "none",
		text_shadow_x_axis = "",
		text_shadow_y_axis = "",
		text_shadow_blur = "";
	//Text shadow color
	//Note:We could use the color from the box-shadow but instead we choose to seperate box-shadow color from text-shadow color
	var text_shadow_r = 0,
		text_shadow_g = 0,
		text_shadow_b = 0,
		text_shadow_opacity = 0,
		text_shadow_color = "";
	var transform_fav = [],
		radius_fav = [],
		box_fav = [],
		text_fav = [];
	var transform_col = 0,
		box_col = 0,
		radius_col = 0,
		text_col = 0; //columns in each table
	var line = [false, false, false, false]; //this array is used to create a new row in each favourite table after adding 3 cells in each row
	//Select which generators you want to see on the page
	var updateText = (selector, text) => domCache.get(selector).text(text);
	var Color = function(red, green, blue, alpha) {
		this.r = red;
		this.g = green;
		this.b = blue;
		this.a = alpha;
		//If no alpa value was provided treat this color as an rgb color by setting alpha value to 1
		//Do not check for any falsy value.Even if 0 is passed as alpha value it is considered as false and
		//makes the next statement true.This is why you must check for undefined and not for false
		if (arguments[3] === undefined)
			this.a = 1;
		this.getColor = function() {
			if (this.a == 1)
				return " rgb(" + this.r + "," + this.g + "," + this.b + ")";
			else
				return " rgba(" + this.r + "," + this.g + "," + this.b + "," + this.a + ")";
			//return this.a==1?" rgb(" + this.r + "," + this.g + "," + this.b + ")":" rgba(" + this.r + "," + this.g + "," + this.b + "," + this.a + ")";
		}
		this.toString = this.getColor;
	};
	var log = (obj) => console.log(obj);
	var len = (obj) => obj.length;

	function saveCode(type) {
		var prefix = (property, value) => {
			var css = "";
			css += "-webkit-" + property + ":" + value + ";\n";
			css += "-moz-" + property + "   :" + value + ";\n";
			css += "-ms-" + property + "    :" + value + ";\n";
			css += property + "             :" + value + ";\n";
			return css;
		};
		var file, blob;
		switch (type) {
			case "f":
				file = "/***\n";
				var favourite_items = "";
				transform_fav.forEach(value => {
					favourite_items += prefix("transform", value);
				});
				box_fav.forEach(value => {
					favourite_items += prefix("box-shadow", value);
				});
				radius_fav.forEach(value => {
					favourite_items += "border-radius:" + value + ";\n";
				});
				//Maybe for text shadow and border radius we can use join()
				//to join the array elements without using forEach
				// if(text_fav.length > 1)
				//favourite_items += (text-shadow+ text_fav.join(";text-shadow:"))+";"
				text_fav.forEach(value => {
					favourite_items += "text-shadow:" + value + ";\n";
				});
				file += favourite_items;
				file += "***/\n";
				break;
			default:
				if (bshadow == "none" && rad == 0 && final_transformation == "none" && text_shadow == "none")
					return;
				file = "div{\n\t";
				if (final_transformation != "none" && final_transformation)
					file += prefix("transform", final_transformation) + "\t";
				if (bshadow && bshadow != "none")
					file += prefix("box-shadow", bshadow) + "\t";
				if (rad != 0)
					file += "border-radius:" + rad + ";\n\t";
				if (text_shadow != "none")
					file += "text-shadow:" + text_shadow + ";\n";
				file += "}";
				break;
		} //switch
		blob = new Blob([file], {
			type: "text/plain;charset=utf-8"
		});
		saveAs(blob, type == 'f' ? 'favourites.css' : 'transformations.css');
	}

	function fav(type) {
		switch (type) {
			case "text-shadow":
				if (text_shadow && text_shadow != "none" && text_fav.indexOf(text_shadow) == -1) {
					text_fav.push(text_shadow);
					if (!line[3]) {
						$("#table_text tbody").append("<tr>");
						line[3] = true;
					}
					if (text_col % 3 == 0) {
						$("#table_text").append("</tr><tr>");
					}
					$("#table_text tbody tr:last").append("<td class='marked text_marked'>" + text_shadow + "</td>");
					text_col++;
					updateText("#text_total", "(" + len(text_fav) + ")")
				}
			case "radius":
				if (rad !== 0 && radius_fav.indexOf(rad) == -1) {
					radius_fav.push(rad);
					if (!line[2]) {
						$("#table_rad tbody").append("<tr>");
						line[2] = true;
					}
					if (radius_col % 3 == 0) {
						$("#table_rad").append("</tr><tr>");
					}
					$("#table_rad tbody tr:last").append("<td class='marked rad_marked'>" + rad + "</td>");
					radius_col++;
					updateText("#radius_total", "(" + len(radius_fav) + ")");
				}
				break;
			case "transform":
				if (final_transformation && transform_fav.indexOf(final_transformation) == -1 && final_transformation !== "rotate(0)" && final_transformation !== "none") {
					//mind the gap after rotate(0)
					transform_fav.push(final_transformation);
					if (!line[0]) {
						$("#table_tran tbody").append("<tr>");
						line[0] = true;
					}
					$("#table_tran tbody tr:last").append("<td class='transform_marked marked'>" + final_transformation + "</td>");
					transform_col++;
					if (transform_col % 3 == 0) {
						$("#table_tran").append("</tr><tr>");
					}
					updateText("#totaltran", "(" + len(transform_fav) + ")");
				}
				break;
			default:
				if (box_fav.indexOf(bshadow) == -1 && bshadow != "none") {
					box_fav.push(bshadow);
					if (!line[1]) {
						$("#table_box tbody").append("<tr>");
						line[1] = true;
					}
					$("#table_box tbody tr:last").append("<td class='box_marked marked'>" + bshadow + "</td>");
					box_col++;
					if (box_col % 3 == 0) {
						$("#table_box").append("</tr><tr>");
					}
					updateText("#box_total", "(" + len(box_fav) + ")");
				} //if
				break;
		} //switch
	} //fav
	function removefav() {
		bootbox.confirm("Are you sure you want to delete your favourites?", function(answer) {
			//bootbox.confirm() requires a callback function as the second parameter
			if (answer) {
				//line[0] = line[1] = line[2] = line[3] = false;
				line = line.map(f => false);
				//empty all the lists
				box_fav.length = radius_fav.length = transform_fav.length = text_fav.length = 0;
				updateText("#box_total,#totaltran,#radius_total,#text_total", "(0)");
				$(".marked").remove();
			}
		});
	}
	var saveToStorage = () => {
		if (!localStorage) {
			bootbox.alert({
				title: "Unsupported API",
				message: "Your browser doesn't support localStorage.Please upgrade to a newer version",
				className: "errorAlert"
			});
		} else {
			let dataExists = !!Lockr.get("appData");
			let options = {};
			//No favourites are available so exit
			//fixes #46
			if (!len(radius_fav) && !len(box_fav) && !len(text_fav) && !len(transform_fav))
				return;
			let app = {
				borderRadius: radius_fav,
				boxShadow: box_fav,
				textShadow: text_fav,
				transform: transform_fav
			};
			if (dataExists) {
				bootbox.confirm({
					title: "Be carefull",
					message: "There is another list of favourites",
					buttons: {
						confirm: {
							label: "Override it",
							className: "btn-warning"
						},
						cancel: {
							label: "Do not override it",
							className: "btn-info"
						}
					},
					callback: (result) => {
						if (result) {
							Lockr.set("appData", app);
							bootbox.alert({
								title: "Override completed",
								buttons: {
									ok: {
										className: "btn-success"
									}
								},
								message: "List has been overrided",
								className: "successAlert"
							});
						} else {
							bootbox.alert({
								title: "Error",
								message: "List override aborted",
								className: "errorAlert"
							});
						}
					},
					className: "warningAlert"
				});
			} else {
				Lockr.set("appData", app)
				bootbox.alert({
					title: "Success",
					message: "Favourites saved to localStorage",
					buttons: {
						ok: {
							className: "btn-success"
						}
					},
					className: "successAlert"
				});
			}
		}
	};
	var checkStorage = () => {
		//Check to see if localStorage is supported and if yes check
		//if there are any data to load
		if (!localStorage || !Lockr.get("appData")) {
			log(!!localStorage ? "No data found" : "localStorage is not supported");
			return;
		}
		//localStorage is supported and there are data to load
		appData = Lockr.get("appData");
		(appData.transform || []).forEach(item => {
			final_transformation = item;
			fav("transform");
		});
		(appData.borderRadius || []).forEach(item => {
			rad = item;
			fav("radius");
		});
		(appData.boxShadow || []).forEach(item => {
			bshadow = item;
			fav();
		});
		(appData.textShadow || []).forEach(item => {
			text_shadow = item;
			fav("text-shadow");
		});
		bootbox.alert({
			title: "Loaded favourites ",
			message: "Favourites loaded",
			className: "successAlert"
		});
		setTimeout(bootbox.hideAll, 3500);
	};
	var selectBg = () => {
		var cssObject = {
			"background": "../css/images/(1).jpg",
			"background-size": "cover"
		};
		var rowIndex = 0;
		var str = "<div class='row'>";
		[1, 2, 3, 4, 5, 6, 7,8].forEach((picNum, index) => {
			if(index && !rowIndex%12)
				str+="</div>";
			rowIndex+=6;
			str+="<div class='col-md-3'><img class='bg-image' src='css/images/"+picNum+".jpg'></div>";

			
		});
		str+="</div>";
		bootbox.alert({
			title: "Choose a background image",
			message: str,
			buttons: {
				ok: {
					label: "Set as background",
					className: "btn-success"
				}
			},
			callback: () => {
				domCache.get("body").css(cssObject);
				log(str);
			}
		});

	};
	var updateMechanism = {
		//This object will update all the relevant variables
		val: function(o) {
			return domCache.get(o).val();
		},
		float: function(value) {
			return parseFloat(this.val(value));
		},
		int: function(value) {
			return parseInt(this.val(value));
		},
		updateTransformationValues: function() {
			x = this.int("#rotatexd");
			y = this.int("#rotatey");
			z = this.int("#rotatez");
			scalex = this.float("#scalex");
			scaley = this.float("#scaley");
			translatex = this.int("#tranx");
			translatey = this.int("#trany");
			translatez = this.int("#tranz");
			skewY = this.int("#skewy");
			skewX = this.int("#skewx");
			return updateMechanism;
		},
		updateBoxShadowValues: function() {
			hor = this.val("#hor_axis");
			ver = this.val("#ver_axis");
			blur = this.val('#blur');
			spread = this.val("#spread");
			transparency = this.float("#trans");
			inset = this.int("#in");
			/*colors*/
			red = this.int("#red");
			green = this.int("#green");
			blue = this.int("#blue");
			return updateMechanism;
		},
		updateTextShadowValues: function() {
			text_shadow_x_axis = this.int("#text_shadow_x");
			text_shadow_y_axis = this.int("#text_shadow_y");
			text_shadow_blur = this.float("#text_shadow_blur");
			text_shadow_r = this.int("#text_shadow_red");
			text_shadow_g = this.int("#text_shadow_green");
			text_shadow_b = this.int("#text_shadow_blue");
			text_shadow_opacity = this.float("#text_shadow_opacity");
			return updateMechanism;
		},
		updateBorderRadiusValues: function() {
			tl = this.val("#tl");
			tr = this.val("#tr");
			bl = this.val("#bl");
			br = this.val("#br");
			return updateMechanism;
		},
		updateAllValues: function() {
			updateMechanism.updateTransformationValues()
				.updateBoxShadowValues()
				.updateTextShadowValues()
				.updateBorderRadiusValues();
		}
	};
	var update = updateMechanism.updateAllValues;
	var createTransformation = () => {
		var transformationValues = [];
		var final_transformation = "";
		if (x)
			transformationValues.push(`rotateX(${x}deg)`);
		if (y)
			transformationValues.push(`rotateY(${y}deg)`);
		if (z)
			transformationValues.push(`rotateZ(${z}deg)`);
		if (scalex !== 1 || scaley !== 1)
			transformationValues.push(`scale(${scalex},${scaley})`);
		if (translatex !== 0 || translatey !== 0 || translatez !== 0) {
			if (translatex !== 0 && translatey == 0 && translatez == 0)
				transformationValues.push(`translateX(${translatex}px)`);
			else if (translatey !== 0 && translatex == 0 && translatez == 0)
				transformationValues.push(`translateY(${translatey}px)`);
			else if (translatez !== 0 && translatex == 0 && translatey == 0)
				transformationValues.push(`translateZ(${translatez}px)`);
			else if (translatex == 0)
				transformationValues.push(`translateY(${translatey}px) translateZ(${translatez}px)`);
			else if (translatez == 0)
				transformationValues.push(`translateX(${translatex}px) translateY(${translatey}px)`);
			else if (translatey == 0)
				transformationValues.push(`translateX(${translatex}px) translateZ(${translatez}px)`);
			else
				transformationValues.push(`translateX(${translatex}px) translateY(${translatey}px) translateZ(${translatez}px)`);
		}
		//if scalex != 1 || scaley != 1 
		//If the skew's sliders have been changed e.g, moved from 0 to 1 or from 0 to 100 add skew property
		if (skewX || skewY)
			transformationValues.push(`skew(${skewX}deg,${skewY}deg)`);
		return transformationValues.join(" ");
	};
	var createTextShadow = () => {
		var shadow = "none";
		//fixes #issue18
		if (text_shadow_x_axis != 0 || text_shadow_y_axis != 0 != text_shadow_blur != 0) {
			/*
			 ** Always add y axis value even if it is zero 
			 */
			shadow = text_shadow_x_axis + "px " + text_shadow_y_axis + "px " + text_shadow_blur + "px ";
			text_shadow_color = new Color(text_shadow_r, text_shadow_g, text_shadow_b, text_shadow_opacity).toString();
			shadow += text_shadow_color;
		}
		return shadow;
	};
	var createBoxShadow = () => {
		var boxShadow;
		//No need to check for color because whatever the color is if the basic sliders are set to 0
		//no shadow will be shown
		if (hor + ver + blur + spread == 0) {
			return "none";
		}
		boxShadow = hor + "px " + ver + "px " + blur + "px " + spread + "px";
		color = new Color(red, green, blue, transparency).toString();
		if (inset) boxShadow = "inset " + boxShadow;
		if (boxShadow != 'none')
			boxShadow += color;
		return boxShadow;
	};
	var createRadius = () => (tl + tr + bl + br) == 0 ? 0 : `${tl}px ${tr}px ${br}px ${bl}px`;
	$(function() {
		demoOutput = domCache.get("#totransform");
		checkStorage();
		setTimeout(()=>{
			domCache.get("#selectBg").attr("disabled",false);
		},3300);
		var decomposer = {
			decomposeColor: (color) => {
				//Extract color values from an rgb colors
				//E.g. rgb(12,44,190)gives [12,44,190]
				var colors = color.split("rgb")[1].split("(")[1].split(",");
				var max = colors.length - 1;
				colors[max] = colors[max].split(")")[0];
				if (len(colors) == 3)
					colors.push(1);
				return colors;
			},
			removeColor: (code) => code.split("rgb")[0],
			//Do not map var.If true is passed the result return is not mapped
			decomposeTextShadow: (code, doNotMap) => {
				code = decomposer.removeColor(code);
				var shadowValues = code.trim().split("px");
				return doNotMap ? shadowValues : shadowValues.map(Number);
			},
			//Since we do the same things as we would in text shadow there is no need to
			//rewrite code
			decomposeBoxShadow: (code) => {
				var inset = code.indexOf("inset") != -1 ? 1 : 0;
				var array = decomposer.decomposeTextShadow(code, true);
				//remove the empty element
				array.pop();
				//Check if there is no spread or blur before pushing inset value
				while (len(array) < 4)
					array.push(0);
				if (inset) {
					array[0] = array[0].split("inset")[1];
				}
				//Only after eerything is finished add the inset slider
				array.push(inset);
				return array.map(Number);
			},
			decomposeRadius: (code) => {
				var radiusValues = code.split("px");
				//You get an array with one empty value which is ""
				//so pop it
				radiusValues.pop();
				//Re arrange the array
				//Values are as following :top left , top right,bottom right, bottom left
				//but the sliders are top left , top right,bottom left, bottom right
				//so swap the last 2 elements 
				var temp = radiusValues[3];
				radiusValues[3] = radiusValues[2];
				radiusValues[2] = temp;
				return radiusValues.map(Number);
			},
			decomposeTransformation: (code) => {
				var getAllIndexes = (arr, val) => {
					var indexes = [],
						i = -1;
					//To understand the second parameter of indexOf function
					//have a look at this : https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf
					while ((i = arr.indexOf(val, i + 1)) != -1) {
						indexes.push(i);
					}
					return indexes;
				};
				var extractRotationValues = (string) => {
					var values = {
						x: 0,
						y: 0,
						z: 0
					};
					string.replace(/\brotate([XYZ])\s*\(\s*([+-]?[\d.]+)\s*deg\s*\)/g, function(_, axis, value) {
						values[axis.toLowerCase()] = parseFloat(value);
					});
					return [values.x, values.y, values.z];
				};
				var extractScaleValues = (string) => {
					return string.indexOf("scale(") != -1 ?
						string.split("scale(")[1].split(")")[0].split(",").map(Number) : [0, 0];
				};
				var extractSkewValues = (string) => {
					if (string.indexOf("skew(") == -1)
						return [0, 0];
					var valueX = string.split("skew(")[1].split("deg,")[0];
					var valueY = string.split("skew(")[1].split("deg,")[1].split("deg")[0];
					return [valueX, valueY].map(Number);
				};
				var extractTranslateValues = (string) => {
					var values = {
						x: 0,
						y: 0,
						z: 0
					};
					string.replace(/\btranslate([XYZ])\s*\(\s*([+-]?[\d.]+)\s*px\s*\)/g, function(_, axis, value) {
						values[axis.toLowerCase()] = parseFloat(value);
					});
					return [values.x, values.y, values.z];
				};
				var rotateValues = extractRotationValues(code);
				var scaleValues = extractScaleValues(code);
				var translateValues = extractTranslateValues(code);
				var skewValues = extractSkewValues(code);
				//Add all values of each array using spread operator
				//See this link for reference
				//https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator
				return [...rotateValues, ...scaleValues, ...translateValues, ...skewValues];
			}
		};
		var sliders = {
			textColors: domCache.get(".text_color"),
			boxColors: domCache.get(".bcolor"),
			boxSliders: domCache.get(".box_shadow:not(.bcolor)"),
			textSliders: domCache.get(".text_shadow_slider"),
			radiusSliders: domCache.get(".radius"),
			transformationSliders: $(".transform_slider"),
			textShadowSliders: () => sliders.textSliders,
			textShadowColors: () => sliders.textColors,
			boxShadowSliders: () => sliders.boxSliders,
			boxShadowColors: () => sliders.boxColors,
			borderRadiusSliders: () => sliders.radiusSliders,
			transformSliders: () => sliders.transformationSliders
		};
		var allGenerators = domCache.get(".generatorContainer");
		var codeOutputs = domCache.get("#export li");
		allGenerators.hide();
		codeOutputs.hide();
		//Show transform generator and its code output
		$(codeOutputs[0]).show();
		$(allGenerators[0]).show();
		$(".navbar-nav a").on("click", function() {
			allGenerators.hide();
			codeOutputs.hide();
			var cur = $(this);
			domCache.get(".navbar-nav li").removeClass("active");
			cur.parent("li").addClass("active");
			var num = cur.data("panel");
			demoOutput.toggle(num != 3);
			$(allGenerators[num]).show(700);
			$(codeOutputs[num]).show(700);
		});
		$("#saveToLocal").on("click", saveToStorage);
		$("#clearLocal").on("click", function() {
			if (!localStorage || !Lockr.get("appData"))
				return;
			bootbox.confirm({
				title: "Warning",
				message: "Are you sure you want to clear localStorage?This will erase your favourites from localStorage",
				buttons: {
					confirm: {
						label: "Clear localStorage",
						className: "btn-danger"
					},
					cancel: {
						className: "btn-info"
					}
				},
				callback: (result) => {
					if (result) {
						Lockr.flush();
						bootbox.alert({
							title: "Operation completed",
							message: "localStorage has been cleared",
							buttons: {
								ok: {
									className: "btn-success"
								}
							},
							className: "successAlert"
						});
					} else {
						bootbox.alert({
							title: "Operation aborted",
							message: "localStorage has not been cleared",
							buttons: {
								ok: {
									className: "btn-info"
								}
							},
							className: "errorAlert"
						});
					}
				},
				className: "warningAlert"
			});
		});
		$("#removeFavouritesBtn").on("click", removefav);
		$("#downloadFavourites").on("click", function() {
			saveCode('f');
		});
		$("#downloadCode").on("click", saveCode);
		$("body").on("click", ".list-group-item.generatorItem", function() {
			$(this).toggleClass("active generatorItemSelected");
		}).on('click', '.modal-backdrop', function(event) {
			bootbox.hideAll();
		});
		$("#code_output .list-group").on("click", ".list-group-item", function() {
			$(this).toggleClass("active");
		});
		$("#addToFavouritesBtn").on("click", function() {
			//Returns an HTMLCollection
			//HTMLCollection does not have a forEach method
			var list = $("#code_output .list-group .list-group-item.active");
			//Convert "list" into an array by slicing it
			[...list].forEach(fn => eval($(fn).data("function")));
		});
		$("#selectBg").on("click",selectBg);
		$("#controllers h1").click(function() {
			$(this).next('.slider_container').toggle(800);
		});
		//var rotate = (axis,deg)=> `rotate${axis}(${deg}deg)`
		$(".ultra_app").on("input change touchmove", function() {
			update();
			final_transformation = createTransformation();
			bshadow = createBoxShadow();
			rad = createRadius();
			text_shadow = createTextShadow();
			demoOutput.css({
				"transform": final_transformation,
				"box-shadow": bshadow,
				"border-radius": rad
			});
			domCache.get("#text_shadow_demo").css("text-shadow", text_shadow);
			updateText('.transform', final_transformation == '' ? 'none' : final_transformation);
			updateText('.box', bshadow);
			updateText('.borderRadius', rad);
			updateText(".text_shadow_code_output", text_shadow);
		});
		$("#restart").click(function() {
			final_transformation = bshadow = text_shadow = "none";
			rad = 0;
			domCache.get('.ultra_app:not(#trans,#text_shadow_opacity,.scale)').val(0);
			// fixes #24
			domCache.get('.scale,#trans,#text_shadow_opacity').val(1);
			demoOutput.css({
				"transform": "none",
				"box-shadow": "none",
				"border-radius": "0"
			});
			domCache.get("#text_shadow_demo").css("text-shadow", "none");
			updateText('.transform,.box,.text_shadow_code_output,.borderRadius', "none");
		});
		$("#table_tran,#table_text,#table_box,#table_rad").on("click", "td", function() {
			var processCode = (code, table) => {
				var sliderValues = [];
				var curSliders = [];
				var colorSliders = [];
				var colorValues = [];
				//This is the output div
				var outputTextSelector = null;
				//The property that will be updated
				var propertyToUpdate = null;
				//Set the sliders depending on the table clicked
				if (table == "#table_tran") {
					propertyToUpdate = "transform";
					outputTextSelector = ".transform";
					final_transformation = code;
					curSliders = sliders.transformSliders();
					final_transformation = code;
					sliderValues = decomposer.decomposeTransformation(final_transformation);
				} else if (table == "#table_text") {
					outputTextSelector = ".text_shadow_code_output";
					text_shadow = code;
					//Here we leave the `propertyToUpdate` set to `null`
					domCache.get("#text_shadow_demo").css("text-shadow", text_shadow);
					curSliders = sliders.textShadowSliders();
					colorSliders = sliders.textShadowColors();
					sliderValues = decomposer.decomposeTextShadow(text_shadow);
					colorValues = decomposer.decomposeColor(text_shadow);
				} else if (table == "#table_box") {
					bshadow = code;
					propertyToUpdate = "box-shadow";
					outputTextSelector = ".box";
					curSliders = sliders.boxShadowSliders();
					colorSliders = sliders.boxShadowColors();
					sliderValues = decomposer.decomposeBoxShadow(bshadow);
					colorValues = decomposer.decomposeColor(bshadow);
				} else {
					rad = code;
					propertyToUpdate = "border-radius";
					outputTextSelector = ".borderRadius";
					curSliders = sliders.borderRadiusSliders();
					sliderValues = decomposer.decomposeRadius(rad);
				}
				//If we don't want to apply text shadow
				if (propertyToUpdate)
					demoOutput.css(propertyToUpdate, code);
				$(outputTextSelector).text(code);
				[...curSliders].forEach(slider => $(slider).val(sliderValues.shift()));
				/*if (colorSliders)*/
				[...colorSliders].forEach(colorSlider => $(colorSlider).val(colorValues.shift()));
			};
			var code = $(this).text();
			//Get the parent table id of the clicked td
			var parentTable = "#" + $(this).closest("table").attr("id");
			processCode(code, parentTable);
		});
	});
}(window.jQuery, window, document));