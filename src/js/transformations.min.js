/*jslint node: true */
'use strict';

(function($, window, document) {
	var map = Array.prototype.map;
	var demoOutput;
	var x = '',
		y = '',
		z = '',
		final_transformation = 'none',
		scalex = '',
		scaley = '',
		translatex = '',
		translatey = '',
		translatez = '',
		skewY = '',
		skewX = '';
	/*is2dmatrix = false;*/ //transformations
	var hor = '',
		ver = '',
		blur = '',
		spread = '',
		inset = '',
		red = "0",
		green = "0",
		blue = "0",
		color = 'rgb(250,48,90)',
		bshadow = 'none',
		transparency = 1; //box-shadow
	var tl = '',
		tr = '',
		bl = '',
		br = '',
		rad = 0; //border-radius
	//Text shadow properies
	var text_shadow = "none",
		text_shadow_x_axis = "",
		text_shadow_y_axis = "",
		text_shadow_blur = "",
		add_text_transform = false;
	//Text shadow color
	//Note:We could use the color from the box-shadow but instead we choose to seperate box-shadow color from text-shadow color
	var text_shadow_r = 0,
		text_shadow_g = 0,
		text_shadow_b = 0,
		text_shadow_opacity = 0,
		text_shadow_color = "";
	var addRadius = false,
		addTransform = false;
	var transform_fav = [],
		radius_fav = [],
		box_fav = [],
		text_fav = [];
	var transform_col = 0,
		box_col = 0,
		radius_col = 0,
		text_col = 0; //columns in each table
	var line = [false, false, false, false]; //this array is used to create a new row in each favourite table after adding 3 cells in each row
	//Select which generators you want to see on the page
	var visibleGenerators = [];
	var selectEnabledGenerators = function(generators) {
		//List of generators to show
		var list = generators;
		var allGenerators = $(".generatorContainer");
		//Hide all generators
		allGenerators.hide();
		//http://stackoverflow.com/questions/41352896/rewrite-for-loop-as-filter-javascript
		//Maybe rewrite it to create a dom string and use it once
		list.forEach(function(item) {
			$(".generatorContainer[data-generator=" + item + "]").show();
		});
	};
	var showGeneratorList = function() {
		var list;
		var markup = "<div class ='panel panel-primary' style='margin-top:10px'>\n\t";
		markup += "<div class='panel-heading'>Choose which generators to show</div>\n\t"
		markup += "<div class='panel-body'>\n\t\t";
		markup += "<div class='list-group'>\n\t\t\t";
		markup += "<div class='list-group-item generatorItem' data-index='0'>CSS Transform</div>\n\t\t\t\t";
		markup += "<div class='list-group-item generatorItem' data-index='1'>CSS Box shadow</div>\n\t\t\t\t";
		markup += "<div class='list-group-item generatorItem' data-index='2'>CSS Border radius</div>\n\t\t\t\t";
		markup += "<div class='list-group-item generatorItem' data-index='3'>CSS Text Shadow</div>\n</div>";
		bootbox.alert({
			message: markup,
			callback: function() {
				//https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map
				list = map.call($(".generatorItemSelected"), function(i) {
					return $(i).data("index");
				});
				if (list)
					selectEnabledGenerators(list);
			}
		});
		//Fix that to avoid collisions with toggle()
		visibleGenerators = $(".generatorContainer:visible");
		//From each visible generatorContainer extract its data-generator value
		var visibleGeneratorsIndex = map.call(visibleGenerators, function(i) {
			return $(i).data("generator");
		});
		//If there are 4 visible generatorContainer it means that all generators are visible
		//so mark them as both active and selected
		if (len(visibleGeneratorsIndex) == 4) {
			$(".generatorItem").addClass("active generatorItemSelected");
		} else {
			var generatorsToSelect = map.call(visibleGeneratorsIndex, function(i) {
				return ".generatorItem[data-index=" + i + "]";
			}).join(",");
			//Each generator that is selected also has to be marked as selected
			$(generatorsToSelect).addClass("active generatorItemSelected");
		}
	};
	var updateText = function(selector, text) {
		$(selector).text(text);
	};
	var Color = function(r, g, b, a) {
		this.r = r;
		this.g = g;
		this.b = b;
		//Check if 0 is passed as an alpha value or a value less than 0
		this.a = a <= 0?a:1;
		this.getColor = function() {
			//Makes it harder to extract color from code string
			/*if (!this.r && !this.g && !this.b && this.a == 1)
				return " black";*/
			if (this.a == 1)
				return " rgb(" + this.r + "," + this.g + "," + this.b + ")";
			else
				return " rgba(" + this.r + "," + this.g + "," + this.b + "," + this.a + ")";
			//return this.a==1?" rgb(" + this.r + "," + this.g + "," + this.b + ")":" rgba(" + this.r + "," + this.g + "," + this.b + "," + this.a + ")";
		}
		this.toString = this.getColor;
	};
	var decomposer = {
		decomposeColor: function(color) {
			//Extract color values from an rgb colors
			//E.g. rgb(12,44,190)gives [12,44,190]
			var colors = color.split("rgb")[1].split("(")[1].split(",");
			var max = colors.length - 1;
			colors[max] = colors[max].split(")")[0];
			return colors;
		},
		removeColor:function(code){
			return code.split("rgb")[0];
		},
		decomposeTextShadow:function(code){
			code = decomposer.removeColor(code);
			var shadowValues = code.trim().split("px");
			return shadowValues.map(Number);
		}
	};
	var log = function(o) {
		console.log(o);
	};
	var len = function(o) {
		return o.length;
	};
	function saveCode(type) {
		var prefix = function(property, value) {
			var css = "";
			css += "-webkit-" + property + ":" + value + ";\n";
			css += "-moz-" + property + "   :" + value + ";\n";
			css += "-ms-" + property + "    :" + value + ";\n";
			css += property + "             :" + value + ";\n";
			return css;
		};
		var file, blob;
		switch (type) {
			case "f":
				file = "/***\n";
				var favourite_items = "";
				transform_fav.forEach(function(value) {
					favourite_items += prefix("transform", value);
				});
				box_fav.forEach(function(value) {
					favourite_items += prefix("box-shadow", value);
				});
				radius_fav.forEach(function(value) {
					favourite_items += "border-radius:" + value + ";\n";
				});
				//Maybe for text shadow and border radius we can use join()
				//to join the array elements without using forEach
				// if(text_fav.length > 1)
				//favourite_items += (text-shadow+ text_fav.join(";text-shadow:"))+";"
				text_fav.forEach(function(value) {
					favourite_items += "text-shadow:" + value + ";\n";
				});
				file += favourite_items;
				file += "***/\n";
				break;
			default:
				if (bshadow == "none" && rad == 0 && final_transformation == "none" && text_shadow == "none")
					return;
				file = "div{\n\t";
				if (final_transformation != "none" && final_transformation)
					file += prefix("transform", final_transformation) + "\t";
				if (bshadow && bshadow != "none")
					file += prefix("box-shadow", bshadow) + "\t";
				if (addRadius)
					file += "border-radius:" + rad + ";\n\t";
				if (add_text_transform)
					file += "text-shadow:" + text_shadow + ";\n";
				file += "}";
				break;
		} //switch
		blob = new Blob([file], {
			type: "text/plain;charset=utf-8"
		});
		saveAs(blob, type == 'f' ? 'favourites.css' : 'transformations.css');
	}
	function fav(type) {
		switch (type) {
			case "text-shadow":
				if (text_shadow && text_shadow != "none" && text_fav.indexOf(text_shadow) == -1) {
					text_fav.push(text_shadow);
					if (!line[3]) {
						$("#table_text tbody").append("<tr>");
						line[3] = true;
					}
					if (text_col % 3 == 0) {
						$("#table_text").append("</tr><tr>");
					}
					$("#table_text tbody tr:last").append("<td class='marked text_marked'>" + text_shadow + "</td>");
					text_col++;
					updateText("#text_total", "(" + len(text_fav) + ")")
				}
			case "radius":
				if (rad !== 0 && radius_fav.indexOf(rad) == -1) {
					radius_fav.push(rad);
					if (!line[2]) {
						$("#table_rad tbody").append("<tr>");
						line[2] = true;
					}
					if (radius_col == 3) {
						radius_col = 0;
						$("#table_rad").append("</tr><tr>");
					}
					$("#table_rad tbody tr:last").append("<td class='marked rad_marked'>" + rad + "</td>");
					radius_col++;
					updateText("#radius_total", "(" + len(radius_fav) + ")");
				}
				break;
			case "transform":
				if (final_transformation && transform_fav.indexOf(final_transformation) == -1 && final_transformation !== "rotate(0)" && final_transformation !== "none") {
					//mind the gap after rotate(0)
					transform_fav.push(final_transformation);
					if (!line[0]) {
						$("#table_tran tbody").append("<tr>");
						line[0] = true;
					}
					$("#table_tran tbody tr:last").append("<td class='transform_marked marked'>" + final_transformation + "</td>");
					transform_col++;
					if (transform_col % 3 == 0) {
						$("#table_tran").append("</tr><tr>");
					}
					updateText("#totaltran", "(" + len(transform_fav) + ")");
				}
				break;
			default:
				if (box_fav.indexOf(bshadow) == -1 && bshadow != "none") {
					box_fav.push(bshadow);
					if (!line[1]) {
						$("#table_box tbody").append("<tr>");
						line[1] = true;
					}
					$("#table_box tbody tr:last").append("<td class='box_marked marked'>" + bshadow + "</td>");
					box_col++;
					if (box_col % 3 == 0) {
						$("#table_box").append("</tr><tr>");
					}
					updateText("#box_total", "(" + len(box_fav) + ")");
				} //if
				break;
		} //switch
	} //fav
	function removefav() {
		bootbox.confirm("Are you sure you want to delete your favourites?", function(answer) {
			//bootbox.confirm() requires a callback function as the second parameter
			if (answer) {
				//line[0] = line[1] = line[2] = line[3] = false;
				line = line.map(function() {
					return false;
				});
				//empty all the lists
				box_fav.length = radius_fav.length = transform_fav.length = text_fav.length = 0;
				updateText("#box_total,#totaltran,#radius_total,#text_total", "(0)");
				$(".marked").remove();
			}
		});
	}
	var updateMechanism = {
		//This object will update all the relevant variables
		val: function(o) {
			return $(o).val();
		},
		float: function(value) {
			return parseFloat(this.val(value));
		},
		int: function(value) {
			return parseInt(this.val(value));
		},
		updateTransformationValues: function() {
			x = this.int("#rotatexd");
			y = this.int("#rotatey");
			z = this.int("#rotatez");
			scalex = this.float("#scalex");
			scaley = this.float("#scaley");
			translatex = this.int("#tranx");
			translatey = this.int("#trany");
			translatez = this.int("#tranz");
			skewY = this.int("#skewy");
			skewX = this.int("#skewx");
			return updateMechanism;
		},
		updateBoxShadowValues: function() {
			hor = this.val("#hor_axis");
			ver = this.val("#ver_axis");
			blur = this.val('#blur');
			spread = this.val("#spread");
			transparency = this.float("#trans");
			inset = this.int("#in");
			/*colors*/
			red = this.int("#red");
			green = this.int("#green");
			blue = this.int("#blue");
			return updateMechanism;
		},
		updateTextShadowValues: function() {
			text_shadow_x_axis = this.int("#text_shadow_x");
			text_shadow_y_axis = this.int("#text_shadow_y");
			text_shadow_blur = this.float("#text_shadow_blur");
			text_shadow_r = this.int("#text_shadow_red");
			text_shadow_g = this.int("#text_shadow_green");
			text_shadow_b = this.int("#text_shadow_blue");
			text_shadow_opacity = this.float("#text_shadow_opacity");
			add_text_transform = text_shadow_x_axis + text_shadow_y_axis + text_shadow_blur != 0;
			return updateMechanism;
		},
		updateBorderRadiusValues: function() {
			tl = this.val("#tl");
			tr = this.val("#tr");
			bl = this.val("#bl");
			br = this.val("#br");
			return updateMechanism;
		},
		updateAllValues: function() {
			updateMechanism.updateTransformationValues()
				.updateBoxShadowValues()
				.updateTextShadowValues()
				.updateBorderRadiusValues();
		}
	};
	var update = updateMechanism.updateAllValues;
	var createTransformation = function() {
		var final_transformation = "";
		if (x)
			final_transformation += "rotateX(" + x + "deg)";
		if (y)
			final_transformation += " rotateY(" + y + "deg)";
		if (z)
			final_transformation += " rotateZ(" + z + "deg)";
		if (scalex !== 1 || scaley !== 1)
			final_transformation += " scale(" + scalex + "," + scaley + ")";
		if (translatex !== 0 || translatey !== 0 || translatez !== 0) {
			if (translatex !== 0 && translatey == 0 && translatez == 0)
				final_transformation += " translateX(" + translatex + "px)";
			else if (translatey !== 0 && translatex == 0 && translatez == 0)
				final_transformation += " translateY(" + translatey + "px)";
			else if (translatez !== 0 && translatex == 0 && translatey == 0)
				final_transformation += " translateZ(" + translatez + "px)";
			else if (translatex == 0)
				final_transformation += " translateY(" + translatey + "px) translateZ(" + translatez + "px)";
			else if (translatez == 0)
				final_transformation += " translateX(" + translatex + "px) translateY(" + translatey + "px)";
			else if (translatey == 0)
				final_transformation += " translateX(" + translatex + "px) translateZ(" + translatez + "px)";
			else
				final_transformation += " translateX(" + translatex + "px) translateY(" + translatey + "px) translateZ(" + translatez + "px)";
		}
		//if scalex != 1 || scaley != 1 
		//If the skew's sliders have been changed e.g, moved from 0 to 1 or from 0 to 100 add skew property
		if (skewX || skewY)
			final_transformation += " skew(" + skewX + "deg," + skewY + "deg)";
		return final_transformation;
	};
	var createTextShadow = function() {
		var shadow = "none";
		//fixes #issue18
		if (text_shadow_x_axis != 0 || text_shadow_y_axis != 0) {
			/*
			 ** Always add y axis value even if it is zero 
			 */
			shadow = text_shadow_x_axis + "px " + text_shadow_y_axis + "px ";
			if (text_shadow_blur)
				shadow += text_shadow_blur + "px ";
			text_shadow_color = new Color(text_shadow_r, text_shadow_g, text_shadow_b, text_shadow_opacity).toString();
			shadow += text_shadow_color;
		}
		return shadow;
	};
	var createBoxShadow = function() {
		var boxShadow;
		//No need to check for color because whatever the color is if the basic sliders are set to 0
		//no shadow will be shown
		if (hor + ver + blur + spread == 0) {
			return "none";
		}
		boxShadow = hor + "px " + ver + "px " + blur + "px " + spread + "px";
		color = new Color(red, green, blue, transparency).toString();
		if (inset) boxShadow = "inset " + boxShadow;
		if (boxShadow != 'none')
			boxShadow += color;
		return boxShadow;
	};
	var createRadius = function() {
		var radius;
		if (tl + tr + bl + br == 0)
			radius = 0;
		else {
			addRadius = true;
			radius = tl + "px " + tr + "px " + br + "px " + bl + "px";
		}
		return radius;
	};
	$(function() {
		var textColors = $(".text_color");
		var textShadowSliders = $(".text_shadow_slider");
		$("#generatorSelector").on("click", showGeneratorList);
		$("#downloadFavourites").on("click", function() {
			saveCode('f');
		});
		$("#downloadCode").on("click", saveCode);
		$("body").on("click", ".list-group-item.generatorItem", function() {
			$(this).toggleClass("active generatorItemSelected");
		}).on('click', '.modal-backdrop', function(event) {
			bootbox.hideAll();
		});
		$("#code_output .list-group").on("click", ".list-group-item", function() {
			$(this).toggleClass("active");
		});
		$("#addToFavouritesBtn").on("click", function() {
			var list = $("#code_output .list-group .list-group-item.active");
			//Convert list into an array by using spread operator
			[...list].forEach(function(fn) {
				eval($(fn).data("function"));
			});
		});
		demoOutput = $("#totransform");
		$("#controllers h1").click(function() {
			$(this).next('.slider_container').toggle(800);
		});
		//var rotate = (axis,deg)=> "rotate"+axis+"("+deg+"deg)";
		$(".ultra_app").on("input change touchmove", function() {
			update();
			final_transformation = createTransformation();
			bshadow = createBoxShadow();
			rad = createRadius();
			text_shadow = createTextShadow();
			demoOutput.css({
				"transform": final_transformation,
				"box-shadow": bshadow,
				"border-radius": rad
			});
			$("#text_shadow_demo").css("text-shadow", text_shadow);
			updateText('.transform', final_transformation == '' ? 'none' : final_transformation);
			updateText('.box', bshadow);
			updateText('.borderRadius', rad);
			updateText(".text_shadow_code_output", text_shadow);
		});
		$("#restart").click(function() {
			final_transformation = bshadow = text_shadow = "none";
			rad = 0;
			$('.ultra_app:not(#trans,.scale,#text_shadow_opacity)').val(0);
			$('.scale,#trans').val(1);
			$("#totransform").css({
				"transform": "none",
				"box-shadow": "none",
				"border-radius": "0"
			});
			$("#text_shadow_demo").css("text-shadow", "none");
			updateText('.transform,.box,.text_shadow_code_output,.borderRadius', "none");
		});
		//Do this for every generator
		$("#table_tran").on("click", 'td', function() {
			final_transformation = $(this).text();
			demoOutput.css("transform", final_transformation);
			//Also print the code in the output panel
			updateText(".transform", final_transformation);
		});
		$("#table_box").on("click", "td", function() {
			bshadow = $(this).text();
			demoOutput.css("box-shadow", bshadow);
			updateText(".box", bshadow);
		});
		$("#table_rad").on("click", "td", function() {
			rad = $(this).text();
			demoOutput.css("border-radius", rad);
			updateText(".borderRadius", rad);
		});
		$("#table_text").on("click", "td", function() {
			text_shadow = $(this).text();
			var colorValues =decomposer.decomposeColor(text_shadow);
			//The current color is rgb so set the Alpha color value to 1
			if(colorValues.length == 3)
				$(textColors[3]).val(1);
			$.each(textColors,function(index,color){
				$(color).val(colorValues.shift());
			});
			var shadowValues = decomposer.decomposeTextShadow(text_shadow);
			//No blur is applied so set it to 0
			if(shadowValues.length==2)
				$(textShadowSliders[2]).val(0);
			$.each(textShadowSliders,function(index,slider){
				$(slider).val(shadowValues.shift());
			});
			$("#text_shadow_demo").css("text-shadow", text_shadow);
			updateText(".text_shadow_code_output", text_shadow);
		});
	});
	// The rest of the code goes here!
}(window.jQuery, window, document));
